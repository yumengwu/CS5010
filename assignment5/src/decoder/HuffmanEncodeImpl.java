package decoder;

import java.util.Comparator;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Queue;
import java.util.PriorityQueue;

/**
 * This class eimplements methods in HuffmanEncode interface. A HuffmanEncodeImpl object could
 * genegrate Huffman code from given text, return all codes, and return original message of an
 * encoded string.
 */
public class HuffmanEncodeImpl implements HuffmanEncode {
  /**
   * This class represent a struct of one symbol and its frequency used in priority queue.
   */
  class SymbolFreqSet {
    private String symbol;
    private int freq;

    /**
     * Construct a symbolFreqSet object by given symbol and its frequency.
     * @param c symbols
     * @param i frequency
     */
    public SymbolFreqSet(String c, int i) {
      this.symbol = c;
      this.freq = i;
    }

    /**
     * Return symbol of this class.
     * @return symbol
     */
    public String getSymbol() {
      return this.symbol;
    }

    /**
     * Return frequency of symbol.
     * @return frequency of symbol
     */
    int getFreq() {
      return this.freq;
    }
  }

  private HashSet<Character> codeSet;
  private Decoder decoder;

  /**
   * Construct a HuffmanEncodeImpl object by given codeSymbol string. Each character in codeSymbol
   * string define a code symbol. If codeSymbol is null or empty string, or contains duplicate
   * characters, this method will throw IllegalStateException.
   * @param codeSymbol codeSymbol define code symbols
   */
  public HuffmanEncodeImpl(String codeSymbol) {
    this.decoder = new DecoderImpl(codeSymbol);
    this.codeSet = new HashSet<>();
    for (int i = 0; i < codeSymbol.length(); ++i) {
      codeSet.add(codeSymbol.charAt(i));
    }
  }

  /**
   * This method will generate Huffman code from given text and return nothing.
   * @param string input string to generate Huffman code
   */
  public void generateHuffmanCode(String string) {
    if (string == null || string.length() == 0) {
      throw new IllegalStateException("Input string cannot be null or empty string");
    }
    Map<Character, Integer> freqTable = new HashMap<>();
    Map<Character, String> codeTable = new HashMap<>();
    for (int i = 0; i < string.length(); ++i) {
      if (freqTable.get(string.charAt(i)) == null) {
        freqTable.put(string.charAt(i), 1);
      }
      else {
        freqTable.put(string.charAt(i), freqTable.get(string.charAt(i)) + 1);
      }
      if (codeTable.get(string.charAt(i)) == null) {
        codeTable.put(string.charAt(i), "");
      }
    }
    Comparator<SymbolFreqSet> comparator = new Comparator<SymbolFreqSet>() {
      @Override
      public int compare(SymbolFreqSet o1, SymbolFreqSet o2) {
        if (o1.getFreq() > o2.getFreq()) {
          return 1;
        }
        else if (o1.getFreq() < o2.getFreq()) {
          return -1;
        }
        else {
          return 0;
        }
      }
    };
    Queue<SymbolFreqSet> queue = new PriorityQueue<>(freqTable.size(), comparator);
    for (Character c : freqTable.keySet()) {
      queue.add(new SymbolFreqSet(c.toString(), freqTable.get(c)));
    }
    if (queue.size() == 1) {
      for (char c : codeSet) {
        SymbolFreqSet sfs = queue.poll();
        codeTable.put(sfs.getSymbol().charAt(0), c + codeTable.get(sfs.getSymbol().charAt(0)));
        break;
      }
    }
    while (queue.size() > 1) {
      SymbolFreqSet [] sfs = new SymbolFreqSet[this.codeSet.size()];
      for (int i = 0; i < sfs.length; ++i) {
        sfs[i] = queue.poll();
      }
      int count = 0;
      for (char c : codeSet) {
        if (sfs[count] == null) {
          continue;
        }
        String currentItem = sfs[count].getSymbol();
        for (int i = 0; i < currentItem.length(); ++i) {
          codeTable.put(currentItem.charAt(i), c + codeTable.get(currentItem.charAt(i)));
        }
        ++count;
      }
      StringBuffer newString = new StringBuffer();
      int newFreq = 0;
      for (int i = 0; i < sfs.length; ++i) {
        if (sfs[i] == null) {
          continue;
        }
        newString.append(sfs[i].getSymbol());
        newFreq += sfs[i].getFreq();
      }
      queue.add(new SymbolFreqSet(newString.toString(), newFreq));
    }
    for (char c : codeTable.keySet()) {
      this.decoder.addCode(c, codeTable.get(c));
    }
  }

  /**
   * This method will return all the symbols and codes in code tree generated by
   * generateHuffmanCode. For each line, if symbol is x and code is yyy, then this line will be
   * x:yyy, with a '\n' in the end of line if this line is not the last line.
   * @return all the symbols and codes in code tree.
   */
  public String allCodes() {
    return this.decoder.allCodes();
  }

  /**
   * This method will encode message by codes generated by generateHuffmanCode and return string
   * after encoded.
   * @param msg the string to encode
   * @return string after encoded
   */
  public String encode(String msg) {
    String [] codeList = this.allCodes().split("\n");
    Map<Character, String> codeMap = new HashMap<>();
    for (int i = 0; i < codeList.length; ++i) {
      if (codeList[i].length() > 0) {
        codeMap.put(codeList[i].charAt(0), codeList[i].substring(2));
      }
      else {
        codeMap.put('\n', codeList[++i].substring(1));
      }
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < msg.length(); ++i) {
      String singleCode = codeMap.get(msg.charAt(i));
      if (singleCode == null) {
        throw new IllegalStateException("Illegal character");
      }
      sb.append(singleCode);
    }
    return sb.toString();
  }

  /**
   * This method will take a encoded text as string and return its original message according
   * to symbol and code from generateHuffmanCode. If input is null or empty string, or input
   * string contain characters not in code symbol set or input string cannot be decoded because
   * the code is not in code tree, this method will throw IllegalStateException.
   * @param msg input string to decode
   * @return original message of input
   */
  public String decode(String msg) {
    return decoder.decode(msg);
  }
}
